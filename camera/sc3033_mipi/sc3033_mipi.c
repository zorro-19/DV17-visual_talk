
#include "asm/iic.h"
#include "asm/isp_dev.h"
#include "gpio.h"
#include "sc3033_mipi.h"
#include "asm/isp_alg.h"

static u32 reset_gpios[2] = {-1, -1};
static u32 pwdn_gpios[2] = {-1, -1};

extern void *sc3033_mipi_get_ae_params();
extern void *sc3033_mipi_get_awb_params();
extern void *sc3033_mipi_get_iq_params();
extern void sc3033_mipi_ae_ev_init(u32 fps);

#define INPUT_CLK  24

#define SC3033_1080P_ROW_CLK  0x898
#define SC3033_1080P_PCLK  74

#define SC3033_1296P_ROW_CLK  0x9c4
#define SC3033_1296P_PCLK  119

#define SC3033_2048x1536_ROW_CLK  0x9c4
#define SC3033_2048x1536_PCLK  119

static void *iic = NULL;

#define WRCMD 0x60
#define RDCMD 0x61


static u32  ROW_CLK   = SC3033_1080P_ROW_CLK;
static u32  PCLK      = SC3033_1080P_PCLK;

typedef struct {
    u16 addr;
    u8 value;
} Sensor_reg_ini;


static Sensor_reg_ini sc3033_mipi_1080p[] = {
    0x0103, 0x01, // soft reset
    0x0100, 0x00,

    0x4500, 0x31, // rnc sel
    0x3416, 0x11,
    0x4501, 0xa4, // bit ctrl

    0x3e03, 0x03, // aec
    0x3e08, 0x00,
    0x3e09, 0x10,
    0x3e01, 0x30,

//old timing
    0x322e, 0x00,
    0x322f, 0xaf,
    0x3306, 0x20,
    0x3307, 0x17,
    0x330b, 0x54,
    0x3303, 0x20,
    0x3309, 0x20,
    0x3308, 0x08,
    0x331e, 0x16,
    0x331f, 0x16,
    0x3320, 0x18,
    0x3321, 0x18,
    0x3322, 0x18,
    0x3323, 0x18,
    0x330c, 0x0b,
    0x330f, 0x07,
    0x3310, 0x42,
    0x3324, 0x07,
    0x3325, 0x07,
    0x335b, 0xca,
    0x335e, 0x07,
    0x335f, 0x10,
    0x3334, 0x00,

//mem write
    0x3F01, 0x04,
    0x3F04, 0x01,
    0x3F05, 0x30,
    0x3626, 0x01,

//analog
    0x3635, 0x60,
    0x3631, 0x84,
    0x3636, 0x8d, //0607
    0x3633, 0x3f,
    0x3639, 0x80,
    0x3622, 0x1e,
    0x3627, 0x02,
    0x3038, 0xa4,
    0x3621, 0x18,
    0x363a, 0x1c,

//ramp
    0x3637, 0xbe,
    0x3638, 0x85,
    0x363c, 0x48, // ramp cur

    0x5780, 0xff, // dpc
    0x5781, 0x04,
    0x5785, 0x10,

//close mipi
//0x301c,0xa4, // dig
//0x301a,0xf8, // ana
//0x3019,0xff,
//0x3022,0x13,

    0x301e, 0xe0, // [4] 0:close tempsens
    0x3662, 0x82,
    0x3d0d, 0x00, // close random code

//2048x1536
    0x3039, 0x20,
    0x303a, 0x35, //74.25M pclk
    0x303b, 0x00,

    0x3306, 0x46,
    0x330b, 0xa0,
    0x3038, 0xf8, //pump clk div

    0x320c, 0x05, //hts=3000
    0x320d, 0xdc,
    0x320e, 0x06, //vts=1584
    0x320f, 0x30,

    0x3202, 0x00, // ystart=48
    0x3203, 0x00,
    0x3206, 0x06, // yend=1545   1545 rows selected
    0x3207, 0x08,

    0x3200, 0x01, // xstart= 264
    0x3201, 0x08,
    0x3204, 0x09, // xend = 2319  2056 cols selected
    0x3205, 0x0f,

    0x3211, 0x04, // xstart
    0x3213, 0x04, // ystart

    0x3208, 0x08, //2048x1536
    0x3209, 0x00,
    0x320a, 0x06,
    0x320b, 0x00,

//0513
    0x3312, 0x06, // sa1 timing
    0x3340, 0x04,
    0x3341, 0xd2,
    0x3342, 0x01,
    0x3343, 0x80,
    0x335d, 0x2a, // cmp timing
    0x3348, 0x04,
    0x3349, 0xd2,
    0x334a, 0x01,
    0x334b, 0x80,
    0x3368, 0x03, // auto precharge
    0x3369, 0x40,
    0x336a, 0x06,
    0x336b, 0x40,
    0x3367, 0x05,
    0x330e, 0x17,

    0x3d08, 0x00, // pclk inv

//fifo
    0x303f, 0x82,
    0x3c03, 0x28, //fifo sram read position
    0x3c00, 0x45, // Dig SRAM reset

//0607
    0x3c03, 0x02, //anti smear
    0x3211, 0x06,
    0x3213, 0x06,
    0x3620, 0x82,


//logic change@ gain<2
    0x3630, 0xb1, //0x67
    0x3635, 0x60, //0x66

//0704
    0x3630, 0x67,
    0x3626, 0x11,

//0910
    0x363c, 0x88, //fine gain correction
    0x3312, 0x00,
    0x3333, 0x80,
    0x3334, 0xa0,
    0x3620, 0x62, //0xd2
    0x3300, 0x10,

//0912
    0x3627, 0x06,
    0x3312, 0x06,
    0x3340, 0x03,
    0x3341, 0x80,
    0x3334, 0x20,

    0x331e, 0x10,
    0x331f, 0x13,
    0x3320, 0x18,
    0x3321, 0x18,

//118.8M pclk 30fps
    0x3039, 0x30,
    0x303a, 0x2a, //118.8M pclk
    0x303b, 0x00,
    0x3640, 0x02,
    0x3641, 0x01,
    0x5000, 0x21,

    0x3340, 0x04,
    0x3342, 0x02,
    0x3343, 0x60,
    0x334a, 0x02,
    0x334b, 0x60,
    0x3306, 0x66,
    0x3367, 0x01,
    0x330b, 0xff,
    0x3300, 0x20,
    0x331f, 0x10,
    0x3f05, 0xe0,
    0x3635, 0x62,


    0x3620, 0x63, //d2

    0x3630, 0x67, //a9,

    0x3633, 0x3d,
    0x363a, 0x04,


//mipi
    0x3c00, 0x00, //[2]: 0  mipi->fifo
    0x303f, 0x02, //[7]: 0  sel pll_pclk
    0x3031, 0x0a, //[3:0] 10bit
    0x3018, 0x73, //[7:5]  sel lane=reg+1


    0x3030, 0x14,

    0x3039, 0x10,
    0x303a, 0x18,
    0x303b, 0x02,
    0x303c, 0x18,

    0x3650, 0x46,

    0x320e, 0x06, // vts=1600
    0x320f, 0x40,

    0x3343, 0x80,
    0x334b, 0x80,
    0x330a, 0x01,
    0x330b, 0x24,


    0x3018, 0x7a, //close unused lane
    0x3019, 0xf0,

    0x3010, 0xe0, //close dvp out
    0x300f, 0xff,
    0x300e, 0x0f,

    0x3640, 0x00,

//1022
    0x3300, 0x38,
    0x3f04, 0x02,
    0x3f05, 0x30,

//1028
    0x3211, 0x04,

//0406
    0x3018, 0x33,
    0x303c, 0x08,
    0x320c, 0x04,
    0x320d, 0x4c,
    0x320e, 0x04,
    0x320f, 0x65, //2200x1125
    0x3039, 0x71,
    0x303a, 0x49,
    0x303b, 0x02,
    0x303c, 0x08,
    0x3035, 0xba,

    0x3208, 0x07, //1920
    0x3209, 0x80,
    0x320a, 0x04, //1080
    0x320b, 0x40,

    0x3202, 0x00, // ystart=4
    0x3203, 0x04,
    0x3206, 0x04, // yend=1114   1115 rows selected
    0x3207, 0x5b,

    0x3200, 0x00, // xstart= 144
    0x3201, 0x90,
    0x3204, 0x08, // xend = 2095  1952 cols selected
    0x3205, 0x2f,

    0x3368, 0x01,
    0x3369, 0x65,
    0x336a, 0x04,
    0x336b, 0x65,
    0x330e, 0x10,

    0x3348, 0x01,
    0x3349, 0x65,
    0x334a, 0x04,
    0x334b, 0x65,
    0x3340, 0x01,
    0x3341, 0x65,
    0x3342, 0x04,
    0x3343, 0x65,

    0x335e, 0x05,
    0x335f, 0x0e,

    0x330a, 0x00,
    0x330b, 0x98,

    0x0100, 0x01,
};


static Sensor_reg_ini sc3033_mipi_1296p[] = {
    0x0103, 0x01, // soft reset
    0x0100, 0x00,

    0x4500, 0x31, // rnc sel
    0x3416, 0x11,
    0x4501, 0xa4, // bit ctrl

    0x3e03, 0x03, // aec
    0x3e08, 0x00,
    0x3e09, 0x10,
    0x3e01, 0x30,

//old timing
    0x322e, 0x00,
    0x322f, 0xaf,
    0x3306, 0x20,
    0x3307, 0x17,
    0x330b, 0x54,
    0x3303, 0x20,
    0x3309, 0x20,
    0x3308, 0x08,
    0x331e, 0x16,
    0x331f, 0x16,
    0x3320, 0x18,
    0x3321, 0x18,
    0x3322, 0x18,
    0x3323, 0x18,
    0x330c, 0x0b,
    0x330f, 0x07,
    0x3310, 0x42,
    0x3324, 0x07,
    0x3325, 0x07,
    0x335b, 0xca,
    0x335e, 0x07,
    0x335f, 0x10,
    0x3334, 0x00,

//mem write
    0x3F01, 0x04,
    0x3F04, 0x01,
    0x3F05, 0x30,
    0x3626, 0x01,

//analog
    0x3635, 0x60,
    0x3631, 0x84,
    0x3636, 0x8d, //0607
    0x3633, 0x3f,
    0x3639, 0x80,
    0x3622, 0x1e,
    0x3627, 0x02,
    0x3038, 0xa4,
    0x3621, 0x18,
    0x363a, 0x1c,

//ramp
    0x3637, 0xbe,
    0x3638, 0x85,
    0x363c, 0x48, // ramp cur

    0x5780, 0xff, // dpc
    0x5781, 0x04,
    0x5785, 0x10,

//close mipi
//0x301c,0xa4, // dig
//0x301a,0xf8, // ana
//0x3019,0xff,
//0x3022,0x13,

    0x301e, 0xe0, // [4] 0:close tempsens
    0x3662, 0x82,
    0x3d0d, 0x00, // close random code

//2048x1536
    0x3039, 0x20,
    0x303a, 0x35, //74.25M pclk
    0x303b, 0x00,

    0x3306, 0x46,
    0x330b, 0xa0,
    0x3038, 0xf8, //pump clk div

    0x320c, 0x05, //hts=3000
    0x320d, 0xdc,
    0x320e, 0x06, //vts=1584
    0x320f, 0x30,

    0x3202, 0x00, // ystart=48
    0x3203, 0x00,
    0x3206, 0x06, // yend=1545   1545 rows selected
    0x3207, 0x08,

    0x3200, 0x01, // xstart= 264
    0x3201, 0x08,
    0x3204, 0x09, // xend = 2319  2056 cols selected
    0x3205, 0x0f,

    0x3211, 0x04, // xstart
    0x3213, 0x04, // ystart

    0x3208, 0x08, //2048x1536
    0x3209, 0x00,
    0x320a, 0x06,
    0x320b, 0x00,

//0513
    0x3312, 0x06, // sa1 timing
    0x3340, 0x04,
    0x3341, 0xd2,
    0x3342, 0x01,
    0x3343, 0x80,
    0x335d, 0x2a, // cmp timing
    0x3348, 0x04,
    0x3349, 0xd2,
    0x334a, 0x01,
    0x334b, 0x80,
    0x3368, 0x03, // auto precharge
    0x3369, 0x40,
    0x336a, 0x06,
    0x336b, 0x40,
    0x3367, 0x05,
    0x330e, 0x17,

    0x3d08, 0x00, // pclk inv

//fifo
    0x303f, 0x82,
    0x3c03, 0x28, //fifo sram read position
    0x3c00, 0x45, // Dig SRAM reset

//0607
    0x3c03, 0x02, //anti smear
    0x3211, 0x06,
    0x3213, 0x06,
    0x3620, 0x82,


//logic change@ gain<2
    0x3630, 0xb1, //0x67
    0x3635, 0x60, //0x66

//0704
    0x3630, 0x67,
    0x3626, 0x11,

//0910
    0x363c, 0x88, //fine gain correction
    0x3312, 0x00,
    0x3333, 0x80,
    0x3334, 0xa0,
    0x3620, 0x62, //0xd2
    0x3300, 0x10,

//0912
    0x3627, 0x06,
    0x3312, 0x06,
    0x3340, 0x03,
    0x3341, 0x80,
    0x3334, 0x20,

    0x331e, 0x10,
    0x331f, 0x13,
    0x3320, 0x18,
    0x3321, 0x18,

//118.8M pclk 30fps
    0x3039, 0x30,
    0x303a, 0x2a, //118.8M pclk
    0x303b, 0x00,
    0x3640, 0x02,
    0x3641, 0x01,
    0x5000, 0x21,

    0x3340, 0x04,
    0x3342, 0x02,
    0x3343, 0x60,
    0x334a, 0x02,
    0x334b, 0x60,
    0x3306, 0x66,
    0x3367, 0x01,
    0x330b, 0xff,
    0x3300, 0x20,
    0x331f, 0x10,
    0x3f05, 0xe0,
    0x3635, 0x62,


    0x3620, 0x63, //d2

    0x3630, 0x67, //a9,

    0x3633, 0x3d,
    0x363a, 0x04,


//mipi
    0x3c00, 0x00, //[2]: 0  mipi->fifo
    0x303f, 0x02, //[7]: 0  sel pll_pclk
    0x3031, 0x0a, //[3:0] 10bit
    0x3018, 0x73, //[7:5]  sel lane=reg+1


    0x3030, 0x14,

    0x3039, 0x10,
    0x303a, 0x18,
    0x303b, 0x02,
    0x303c, 0x18,

    0x3650, 0x46,

    0x320e, 0x06, // vts=1600
    0x320f, 0x40,

    0x3343, 0x80,
    0x334b, 0x80,
    0x330a, 0x01,
    0x330b, 0x24,


    0x3018, 0x7a, //close unused lane
    0x3019, 0xf0,

    0x3010, 0xe0, //close dvp out
    0x300f, 0xff,
    0x300e, 0x0f,

    0x3640, 0x00,

//1022
    0x3300, 0x38,
    0x3f04, 0x02,
    0x3f05, 0x30,

//1028
    0x3211, 0x04,

//0406
    0x3018, 0x33,
    0x303c, 0x08,
    0x320c, 0x04,
    0x320d, 0xe2,
    0x320e, 0x06,
    0x320f, 0x30, //2500x1584
    0x3039, 0x20,
    0x303a, 0x5f,
    0x303b, 0x02,
    0x303c, 0x08,
    0x3035, 0xba,

    0x3208, 0x09, //2304
    0x3209, 0x00,
    0x320a, 0x05, //1296
    0x320b, 0x10,

    0x3202, 0x00, // ystart=4
    0x3203, 0x04,
    0x3206, 0x06, // yend=1544   1541 rows selected
    0x3207, 0x08,

    0x3200, 0x00, // xstart= 144
    0x3201, 0x90,
    0x3204, 0x09, // xend = 2455  2312 cols selected
    0x3205, 0x97,

    0x3368, 0x03,
    0x3369, 0x30,
    0x336a, 0x06,
    0x336b, 0x30,

    0x335e, 0x05,
    0x335f, 0x0e,

    0x330a, 0x01,
    0x330b, 0x00,

    0x0100, 0x01,
};


static Sensor_reg_ini sc3033_mipi_2048x1536[] = {

    0x0103, 0x01, // soft reset
    0x0100, 0x00,

    0x4500, 0x31, // rnc sel
    0x3416, 0x11,
    0x4501, 0xa4, // bit ctrl

    0x3e03, 0x03, // aec
    0x3e08, 0x00,
    0x3e09, 0x10,
    0x3e01, 0x30,

//old timing
    0x322e, 0x00,
    0x322f, 0xaf,
    0x3306, 0x20,
    0x3307, 0x17,
    0x330b, 0x54,
    0x3303, 0x20,
    0x3309, 0x20,
    0x3308, 0x08,
    0x331e, 0x16,
    0x331f, 0x16,
    0x3320, 0x18,
    0x3321, 0x18,
    0x3322, 0x18,
    0x3323, 0x18,
    0x330c, 0x0b,
    0x330f, 0x07,
    0x3310, 0x42,
    0x3324, 0x07,
    0x3325, 0x07,
    0x335b, 0xca,
    0x335e, 0x07,
    0x335f, 0x10,
    0x3334, 0x00,

//mem write
    0x3F01, 0x04,
    0x3F04, 0x01,
    0x3F05, 0x30,
    0x3626, 0x01,

//analog
    0x3635, 0x60,
    0x3631, 0x84,
    0x3636, 0x8d, //0607
    0x3633, 0x3f,
    0x3639, 0x80,
    0x3622, 0x1e,
    0x3627, 0x02,
    0x3038, 0xa4,
    0x3621, 0x18,
    0x363a, 0x1c,

//ramp
    0x3637, 0xbe,
    0x3638, 0x85,
    0x363c, 0x48, // ramp cur

    0x5780, 0xff, // dpc
    0x5781, 0x04,
    0x5785, 0x10,

//close mipi
//0x301c,0xa4, // dig
//0x301a,0xf8, // ana
//0x3019,0xff,
//0x3022,0x13,

    0x301e, 0xe0, // [4] 0:close tempsens
    0x3662, 0x82,
    0x3d0d, 0x00, // close random code

//2048x1536
    0x3039, 0x20,
    0x303a, 0x35, //74.25M pclk
    0x303b, 0x00,

    0x3306, 0x46,
    0x330b, 0xa0,
    0x3038, 0xf8, //pump clk div

    0x320c, 0x05, //hts=3000
    0x320d, 0xdc,
    0x320e, 0x06, //vts=1584
    0x320f, 0x30,

    0x3202, 0x00, // ystart=48
    0x3203, 0x00,
    0x3206, 0x06, // yend=1545   1545 rows selected
    0x3207, 0x08,

    0x3200, 0x01, // xstart= 264
    0x3201, 0x08,
    0x3204, 0x09, // xend = 2319  2056 cols selected
    0x3205, 0x0f,

    0x3211, 0x04, // xstart
    0x3213, 0x04, // ystart

    0x3208, 0x08, //2048x1536
    0x3209, 0x00,
    0x320a, 0x06,
    0x320b, 0x00,

//0513
    0x3312, 0x06, // sa1 timing
    0x3340, 0x04,
    0x3341, 0xd2,
    0x3342, 0x01,
    0x3343, 0x80,
    0x335d, 0x2a, // cmp timing
    0x3348, 0x04,
    0x3349, 0xd2,
    0x334a, 0x01,
    0x334b, 0x80,
    0x3368, 0x03, // auto precharge
    0x3369, 0x40,
    0x336a, 0x06,
    0x336b, 0x40,
    0x3367, 0x05,
    0x330e, 0x17,

    0x3d08, 0x00, // pclk inv

//fifo
    0x303f, 0x82,
    0x3c03, 0x28, //fifo sram read position
    0x3c00, 0x45, // Dig SRAM reset

//0607
    0x3c03, 0x02, //anti smear
    0x3211, 0x06,
    0x3213, 0x06,
    0x3620, 0x82,


//logic change@ gain<2
    0x3630, 0xb1, //0x67
    0x3635, 0x60, //0x66

//0704
    0x3630, 0x67,
    0x3626, 0x11,

//0910
    0x363c, 0x88, //fine gain correction
    0x3312, 0x00,
    0x3333, 0x80,
    0x3334, 0xa0,
    0x3620, 0x62, //0xd2
    0x3300, 0x10,

//0912
    0x3627, 0x06,
    0x3312, 0x06,
    0x3340, 0x03,
    0x3341, 0x80,
    0x3334, 0x20,

    0x331e, 0x10,
    0x331f, 0x13,
    0x3320, 0x18,
    0x3321, 0x18,

//118.8M pclk 30fps
    0x3039, 0x30,
    0x303a, 0x2a, //118.8M pclk
    0x303b, 0x00,
    0x3640, 0x02,
    0x3641, 0x01,
    0x5000, 0x21,

    0x3340, 0x04,
    0x3342, 0x02,
    0x3343, 0x60,
    0x334a, 0x02,
    0x334b, 0x60,
    0x3306, 0x66,
    0x3367, 0x01,
    0x330b, 0xff,
    0x3300, 0x20,
    0x331f, 0x10,
    0x3f05, 0xe0,
    0x3635, 0x62,


    0x3620, 0x63, //d2

    0x3630, 0x67, //a9,

    0x3633, 0x3d,
    0x363a, 0x04,


//mipi
    0x3c00, 0x00, //[2]: 0  mipi->fifo
    0x303f, 0x02, //[7]: 0  sel pll_pclk
    0x3031, 0x0a, //[3:0] 10bit
    0x3018, 0x73, //[7:5]  sel lane=reg+1


    0x3030, 0x14,

    0x3039, 0x10,
    0x303a, 0x18,
    0x303b, 0x02,
    0x303c, 0x18,

    0x3650, 0x46,

    0x320e, 0x06, // vts=1600
    0x320f, 0x40,

    0x3343, 0x80,
    0x334b, 0x80,
    0x330a, 0x01,
    0x330b, 0x24,


    0x3018, 0x7a, //close unused lane
    0x3019, 0xf0,

    0x3010, 0xe0, //close dvp out
    0x300f, 0xff,
    0x300e, 0x0f,

    0x3640, 0x00,

//1022
    0x3300, 0x38,
    0x3f04, 0x02,
    0x3f05, 0x30,

//1028
    0x3211, 0x04,

//0406
    0x3018, 0x33,
    0x303c, 0x08,
    0x320c, 0x04,
    0x320d, 0xe2,
    0x320e, 0x06,
    0x320f, 0x30, //2500x1584
    0x3039, 0x20,
    0x303a, 0x5f,
    0x303b, 0x02,
    0x303c, 0x08,
    0x330a, 0x01,
    0x330b, 0x00,
    0x3306, 0x76,
    0x3035, 0xba,

    0x0100, 0x01,
};



unsigned char wrSC3033_mipi_Reg(u16 regID, unsigned char regDat)
{
    u8 ret = 1;

    dev_ioctl(iic, IIC_IOCTL_START, 0);

    if (dev_ioctl(iic, IIC_IOCTL_TX_WITH_START_BIT, WRCMD)) {
        ret = 0;
        goto __wend;
    }

    delay(100);

    if (dev_ioctl(iic, IIC_IOCTL_TX, regID >> 8)) {
        ret = 0;
        goto __wend;
    }

    delay(100);

    if (dev_ioctl(iic, IIC_IOCTL_TX, regID & 0xff)) {
        ret = 0;
        goto __wend;
    }

    delay(100);

    if (dev_ioctl(iic, IIC_IOCTL_TX_WITH_STOP_BIT, regDat)) {
        ret = 0;
        goto __wend;
    }

__wend:

    dev_ioctl(iic, IIC_IOCTL_STOP, 0);
    return ret;

}

unsigned char rdSC3033_mipi_Reg(u16 regID, unsigned char *regDat)
{
    u8 ret = 1;
    dev_ioctl(iic, IIC_IOCTL_START, 0);
    if (dev_ioctl(iic, IIC_IOCTL_TX_WITH_START_BIT, WRCMD)) {
        ret = 0;
        goto __rend;
    }

    delay(100);

    if (dev_ioctl(iic, IIC_IOCTL_TX, regID >> 8)) {
        ret = 0;
        goto __rend;
    }

    if (dev_ioctl(iic, IIC_IOCTL_TX_WITH_STOP_BIT, regID & 0xff)) {
        ret = 0;
        goto __rend;
    }

    delay(100);

    if (dev_ioctl(iic, IIC_IOCTL_TX_WITH_START_BIT, RDCMD)) {
        ret = 0;
        goto __rend;
    }

    delay(1000);

    dev_ioctl(iic, IIC_IOCTL_RX_WITH_STOP_BIT, (u32)regDat);

__rend:

    dev_ioctl(iic, IIC_IOCTL_STOP, 0);
    return ret;

}


/*************************************************************************************************
    sensor api
*************************************************************************************************/

s32 _sc3033_mipi_set_output_size(u16 *width, u16 *height, u8 *frame_freq)
{
    int i;
    /*printf("sc3033_mipi_set_output_size : %dx%d@%d\n", *width, *height, *frame_freq);*/
    if (*width == 1920 && *height == 1088) {
        for (i = 0; i < sizeof(sc3033_mipi_1080p) / sizeof(Sensor_reg_ini); i++) {
            wrSC3033_mipi_Reg(sc3033_mipi_1080p[i].addr, sc3033_mipi_1080p[i].value);
        }
        ROW_CLK = SC3033_1080P_ROW_CLK;
        PCLK = SC3033_1080P_PCLK;
    } else if (*width == 2304 && *height == 1296) {
        for (i = 0; i < sizeof(sc3033_mipi_1296p) / sizeof(Sensor_reg_ini); i++) {
            wrSC3033_mipi_Reg(sc3033_mipi_1296p[i].addr, sc3033_mipi_1296p[i].value);
        }
        ROW_CLK = SC3033_1296P_ROW_CLK;
        PCLK = SC3033_1296P_PCLK;

    } else if (*width == 2048 && *height == 1536) {
        for (i = 0; i < sizeof(sc3033_mipi_2048x1536) / sizeof(Sensor_reg_ini); i++) {
            wrSC3033_mipi_Reg(sc3033_mipi_2048x1536[i].addr, sc3033_mipi_2048x1536[i].value);
        }
        ROW_CLK = SC3033_2048x1536_ROW_CLK;
        PCLK = SC3033_2048x1536_PCLK;
    } else {
        printf("sc3033_mipi_set_output_size failed! %dx%d@%d\n", *width, *height, *frame_freq);
    }

    return 0;
}

void sc3033_mipi_config_SENSOR(u16 *width, u16 *height, u8 *format, u8 *frame_freq)
{
    _sc3033_mipi_set_output_size(width, height, frame_freq);

    sc3033_mipi_ae_ev_init(*frame_freq);

    return;
}



s32 sc3033_mipi_set_output_size(u16 *width, u16 *height, u8 *frame_freq)
{
    if (*frame_freq == 15) {
        wrSC3033_mipi_Reg(0x320e, 0x08);
        wrSC3033_mipi_Reg(0x320f, 0xca);
    } else {
        wrSC3033_mipi_Reg(0x320e, 0x04);
        wrSC3033_mipi_Reg(0x320f, 0x65);
    }
    return 0;
    /*return _sc3033_mipi_set_output_size(width, height, frame_freq);*/
}

s32 sc3033_mipi_get_mipi_clk(u32 *mipi_clk, u32 *tval_hstt, u32 *tval_stto, u16 width, u16 height, u8 frame_freq)
{
    u32 clk;
    if (width == 1920 && height == 1088) {
        *mipi_clk = 225;
        *tval_hstt = 0;
        *tval_stto = 30;
    } else if (width == 2304 && height == 1296) {
        *mipi_clk = 296;
        *tval_hstt = 0;
        *tval_stto = 30;
    } else if (width == 2048 && height == 1536) {
        *mipi_clk = 296;
        *tval_hstt = 0;
        *tval_stto = 30;
    } else {
        *mipi_clk = 225;
        *tval_hstt = 0;
        *tval_stto = 30;
    }
    return 0;
}

s32 sc3033_mipi_power_ctl(u8 isp_dev, u8 is_work)
{

    return 0;
}

s32 sc3033_mipi_ID_check(void)
{
    u8 pid = 0x00;
    u8 ver = 0x00;
    u8 i ;

    for (i = 0; i < 3; i++) { //
        rdSC3033_mipi_Reg(0x3107, &pid);
        rdSC3033_mipi_Reg(0x3108, &ver);
    }

    /*puts("Sensor PID \n");
    put_u8hex(pid);
    put_u8hex(ver);
    puts("\n");*/

    if (pid != 0x30 && ver != 0x35) {
        puts("\n----not sc3033_mipi-----\n");
        return -1;
    }
    puts("\n----hello sc3033_mipi-----\n");
    return 0;
}

void sc3033_mipi_reset(u8 isp_dev)
{
    u32 reset_gpio;
    u32 pwdn_gpio;

    if (isp_dev == ISP_DEV_0) {
        reset_gpio = reset_gpios[0];
        pwdn_gpio = pwdn_gpios[0];
    } else {
        reset_gpio = reset_gpios[1];
        pwdn_gpio = pwdn_gpios[1];
    }
    gpio_direction_output(pwdn_gpio, 0);

    gpio_direction_output(reset_gpio, 0);
    delay(40000);
    gpio_direction_output(reset_gpio, 1);
    delay(40000);
}


static u8 cur_sensor_type = 0xff;

s32 sc3033_mipi_check(u8 isp_dev, u32 reset_gpio, u32 pwdn_gpio)
{
    /*puts("\n\n sc3033_mipi_check \n\n");*/
    if (!iic) {
        if (isp_dev == ISP_DEV_0) {
            iic = dev_open("iic0", 0);
        } else {
            iic = dev_open("iic1", 0);
        }
        if (!iic) {
            return -1;
        }
    } else {
        if (cur_sensor_type != isp_dev) {
            return -1;
        }
    }
    /*printf("\n\n isp_dev =%d\n\n", isp_dev);*/

    reset_gpios[isp_dev] = reset_gpio;
    pwdn_gpios[isp_dev] = pwdn_gpio;

    sc3033_mipi_reset(isp_dev);

    if (0 != sc3033_mipi_ID_check()) {
        dev_close(iic);
        iic = NULL;
        return -1;
    }

    cur_sensor_type = isp_dev;

    return 0;
}

void resetStatic();
s32 sc3033_mipi_init(u8 isp_dev, u16 *width, u16 *height, u8 *format, u8 *frame_freq)
{
    sc3033_mipi_reset(isp_dev);
    /*puts("\n\n sc3033_mipi_init22 \n\n");*/

    sc3033_mipi_config_SENSOR(width, height, format, frame_freq);

    return 0;
}


static void set_again(u32 again)
{
    return;
}

static void set_dgain(u32 dgain)
{

    wrSC3033_mipi_Reg(0x3e08, (dgain >> 8));
    wrSC3033_mipi_Reg(0x3e09, dgain & 0xff);
}

//q10
static void calc_gain(u32 gain, u32 *again, u32 *dgain)
{
    u32 ag;
    *again = 0;
    *dgain = gain * 0x10 / (1 << 10);
}

static void set_shutter(u32 texp)
{
    wrSC3033_mipi_Reg(0x3e01, texp >> 4);
    wrSC3033_mipi_Reg(0x3e02, (texp << 4) & 0xf0);
}


u32 sc3033_mipi_calc_shutter(isp_ae_shutter_t *shutter, u32 exp_time_us, u32 gain)
{
    u32 texp;
    u32 texp_align;
    u32 ratio;

    texp = exp_time_us * PCLK / ROW_CLK;
    texp_align = (texp) * ROW_CLK / (PCLK);
    //printf("exp_time_us=%d, texp=%d, texp_align=%d\n", exp_time_us, texp, texp_align);
    if (texp_align < exp_time_us) {
        ratio = (exp_time_us) * (1 << 10) / texp_align;

    } else {
        ratio = (1 << 10);
    }

    shutter->ae_exp_line =  texp;
    shutter->ae_gain = (gain * ratio) >> 10;
    shutter->ae_exp_clk = 0;

    return 0;

}



u32 sc3033_mipi_set_shutter(isp_ae_shutter_t *shutter)
{

    u32 again, dgain;
    u8 val_0x3109;


    calc_gain((shutter->ae_gain), &again, &dgain);
    //printf("sc3033, again=%x, dgain=%x\n", again, dgain);

    set_again(again);
    set_dgain(dgain);

    set_shutter(shutter->ae_exp_line);


    rdSC3033_mipi_Reg(0x3109, &val_0x3109);


    if (dgain < 0x20) {
        wrSC3033_mipi_Reg(0x3630, 0xa9);
        wrSC3033_mipi_Reg(0x3627, 0xa2);
        wrSC3033_mipi_Reg(0x3635, 0x66);
#if 0
    } else if (dgain >= 0x20 && dgain <= 0x100) {
        wrSC3033_mipi_Reg(0x3630, 0x67);
        wrSC3033_mipi_Reg(0x3627, 0x02);
        wrSC3033_mipi_Reg(0x3635, 0x64);
    } else {
        wrSC3033_mipi_Reg(0x3630, 0x67);
        wrSC3033_mipi_Reg(0x3627, 0x06);
        wrSC3033_mipi_Reg(0x3635, 0x62);
    }
#else
    } else
    {
        wrSC3033_mipi_Reg(0x3630, 0x67);
        wrSC3033_mipi_Reg(0x3627, 0x02);
        wrSC3033_mipi_Reg(0x3635, 0x64);
    }
#endif

    if (val_0x3109 == 0x02)
    {
        if (dgain < 0x20) {
            wrSC3033_mipi_Reg(0x3620, 0xd2);
        } else {
            wrSC3033_mipi_Reg(0x3620, 0x63);
        }

    } else if (val_0x3109 == 0x03)
    {
        if (dgain < 0x20) {
            wrSC3033_mipi_Reg(0x3620, 0x62);
        } else {
            wrSC3033_mipi_Reg(0x3620, 0x63);
        }
    }




    return 0;
}

void sc3033_mipi_sleep()
{


}

void sc3033_mipi_wakeup()
{


}

void sc3033_mipi_W_Reg(u16 addr, u16 val)
{
    /*printf("update reg%x with %x\n", addr, val);*/
    wrSC3033_mipi_Reg((u16)addr, (u8)val);
}
u16 sc3033_mipi_R_Reg(u16 addr)
{
    u8 val;
    rdSC3033_mipi_Reg((u16)addr, &val);
    return val;
}



REGISTER_CAMERA(sc3033_mipi) = {
    .logo 				= 	"sc3033m",
    .isp_dev 			= 	ISP_DEV_NONE,
    .in_format 			= 	SEN_IN_FORMAT_BGGR,
    .out_format 		= 	ISP_OUT_FORMAT_YUV,
    .mbus_type          =   SEN_MBUS_CSI2,
    .mbus_config        =   SEN_MBUS_DATA_WIDTH_10B | SEN_MBUS_CSI2_2_LANE,
    .fps         		= 	30,

    .sen_size 			= 	{SC3033_MIPI_OUTPUT_W, SC3033_MIPI_OUTPUT_H},
    .isp_size 			= 	{SC3033_MIPI_OUTPUT_W, SC3033_MIPI_OUTPUT_H},

    .cap_fps         		= 	30,
    .sen_cap_size 			= 	{SC3033_MIPI_OUTPUT_W, SC3033_MIPI_OUTPUT_H},
    .isp_cap_size 			= 	{SC3033_MIPI_OUTPUT_W, SC3033_MIPI_OUTPUT_H},

    .ops                =   {
        .avin_fps           =   NULL,
        .avin_valid_signal  =   NULL,
        .avin_mode_det      =   NULL,
        .sensor_check 		= 	sc3033_mipi_check,
        .init 		        = 	sc3033_mipi_init,
        .set_size_fps 		=	sc3033_mipi_set_output_size,
        .get_mipi_clk 		=	sc3033_mipi_get_mipi_clk,
        .power_ctrl         =   sc3033_mipi_power_ctl,

        .get_ae_params  	=	sc3033_mipi_get_ae_params,
        .get_awb_params 	=	sc3033_mipi_get_awb_params,
        .get_iq_params 	    	=	sc3033_mipi_get_iq_params,

        .sleep 		        =	sc3033_mipi_sleep,
        .wakeup 		    =	sc3033_mipi_wakeup,
        .write_reg 		    =	sc3033_mipi_W_Reg,
        .read_reg 		    =	sc3033_mipi_R_Reg,

    }
};


